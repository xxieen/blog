<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="../../favicon.png"
    />
    <meta name="viewport" content="width=device-width" />
    
		<link href="../../_app/immutable/assets/0.DKyA2uc9.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/3.BF2wmC3k.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.CIgtfsuB.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/entry.Cmpd7xjo.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/scheduler.DKuV8lkR.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.-TmmM991.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.C2LByF26.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.BWbrWu7K.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.BMc9WXMc.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/3.DDTzhz-d.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/dates.D2szYS5F.js"><!-- HEAD_svelte-3wfvcu_START --><script data-svelte-h="svelte-1qrl023">window.prefersDarkmode = false;

    if (
      localStorage.theme === "dark" ||
      (!localStorage.theme &&
        window.matchMedia("(prefers-color-scheme: dark)")
          .matches)
    ) {
      window.prefersDarkmode = true;
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }</script><!-- HEAD_svelte-3wfvcu_END -->
  </head>
  <body
    data-sveltekit-preload-data="hover"
    class="dark:bg-dark-background dark:text-white"
  >
    <div style="display: contents">   <header class="fixed inset-x-0 top-0 z-10 border-b bg-white dark:border-gray-800 dark:bg-dark-background"><nav class="mx-auto flex h-24 max-w-5xl items-center justify-between px-4"><a href="/"><svg class="h-40 w-40" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 85 50" style="enable-background:new 0 0 85 50;" xml:space="preserve"><style type="text/css">.st0 {
      fill: #8486a6;
    }
    .st1 {
      fill: #71738f;
    }
    .st2 {
      fill: #d2d2d9;
    }
    .st3 {
      fill: #ecebeb;
    }
    .st4 {
      fill: #f5f5f5;
    }
    .st5 {
      fill: #ee9c79;
    }
    .st6 {
      fill: #de9070;
    }
    .st7 {
      fill: #ff4646;
    }
    .st8 {
      fill: #ffffff;
    }
    .st9 {
      fill: #dedede;
    }
    .st10 {
      fill: #613c24;
    }
    .st11 {
      fill: #553520;
    }
    .st12 {
      fill: #b63c3c;
    }
    .st13 {
      fill: none;
      stroke: #db8f6f;
      stroke-width: 0.5;
      stroke-linecap: round;
      stroke-miterlimit: 10;
    }
    .st14 {
      fill: #dbdada;
    }
    .st15 {
      fill: #e6e4e4;
    }
  </style><path class="st0" d="M49.5,48.9v-1H31.9v1.9h17.1L49.5,48.9L49.5,48.9z"></path><path class="st1" d="M41.7,47.9l-1.2,1.9h-8.6v-1.9H41.7L41.7,47.9z"></path><path class="st2" d="M56.2,24.5L47,49.8h1.6l9.3-25.3H56.2L56.2,24.5z"></path><path class="st3" d="M73.4,49.8l8.9-24.5l-24.4-0.8l-9.3,25.3H73.4L73.4,49.8z"></path><polygon class="st4" points="80.6,29.9 77.6,38.3 62.6,49.8 53.6,49.8 65.7,41 65.6,41.4 66.8,41.7 67.1,40 67.1,39.9 68.6,38.8 
	68.7,39 69.3,39.8 72,37.4 71.7,37.1 71.4,36.7 "></polygon><path class="st4" d="M68.3,49.8l7.1-5.5l-2,5.5H68.3z"></path><path class="st5" d="M9.1,45.7l-0.1,1L8.8,48c-2.3,0.2-5.6,1.2-7.4,1.7C1,49.8,0.7,49.9,0.5,50c0-0.3,0.1-3.2,0.3-5.1
	c0,0,0.5-0.3,1.3-0.6l0,0c1.4-0.7,3.6-1.8,3.8-1.9c0.1,0,0.2,0,0.4,0.2C7.2,43.3,9.1,45.7,9.1,45.7L9.1,45.7L9.1,45.7z"></path><path class="st6" d="M9.9,46.6l-0.9,0l-7.4,0.2l-0.2,2.8C1,49.8,0.7,49.9,0.5,50c0-0.3,0.1-3.2,0.3-5.1c0,0,0.5-0.3,1.3-0.6l0,0
	l4.2-1.7l1.8-0.7L9.9,46.6L9.9,46.6L9.9,46.6z"></path><path class="st5" d="M32.1,43.5c0.9-1.6,5.2-4.7,6.9-5c0.6,0,0.1,2-1.9,2.9c1.7-0.2,9-0.3,8.9,0.8c0,0.9-0.3,1-0.8,2.2
	s-0.5,2.5-1.6,2.8c-2.7,1-2.1-0.6-6.3,0.3c-1.3,0.7-2,1.8-3.1,2.1L32.1,43.5L32.1,43.5L32.1,43.5z"></path><path class="st7" d="M32.2,43.6c0.7-1,4.8-4.4,6.5-5c0.3-1.4-1.9-9.8-3.5-10.5c-1.7-1-3.9-1.7-4.8-1.9c-0.3-0.1-1.3-0.5-2.6-0.8
	c0,0-0.1,0-0.1,0c-2.8-0.7-7.1-1.6-9.9-1.6c-0.3,0-0.6,0-0.9,0c-0.3,0-0.6,0.1-1,0.1c-3.5,0.4-10.8,1.6-11.8,3
	C2.6,29.7-1.3,41.9,0.5,50h30.7c0,0,2.4,0,3.1-0.6C34.3,46.5,32.8,43.7,32.2,43.6L32.2,43.6L32.2,43.6z"></path><path class="st8" d="M28.3,25.7c0,0.2,0,0.4-0.1,0.6c0,0.4-0.1,0.8-0.3,1.2c-0.1,0.3-0.3,0.6-0.5,0.8c-3.6,5.9-12.6,3.4-11.7-4.4
	c0.4-0.1,0.7-0.1,1-0.1c0.3,0,0.6,0,0.9,0c2.9,0,7.4,1,10.4,1.9C28.2,25.7,28.2,25.7,28.3,25.7L28.3,25.7L28.3,25.7z"></path><path class="st5" d="M26.9,26.8c0.1,2.3-8.6,5.5-9.4-1c-0.1-0.5-0.1-1.1,0-1.8c0.5-0.7,1-3.4,1.4-5.9c0-0.1,0-0.1,0.1-0.2
	C19.6,16.5,26.7,22.6,26.9,26.8L26.9,26.8L26.9,26.8z"></path><g><path class="st6" d="M18.8,18.1c0,0,8.1,8.3,8.1,8.6C21.2,26.8,19,24.3,18.8,18.1z"></path><path class="st6" d="M20.2,19.6l-0.5,1c0,0-0.6,3.8-2.2,5.2c-0.1-0.5-0.1-1.1,0-1.8c0.5-0.7,1-3.4,1.4-5.9l1.3-0.2L20.2,19.6
		L20.2,19.6z"></path></g><path class="st9" d="M28.3,25.7c0,0,0,1.4-0.5,2l-1.2-0.1c0,0,0.4-0.6,0.3-1.1s0.6-1.6,0.6-1.6L28.3,25.7L28.3,25.7z"></path><path class="st5" d="M32.2,14.2c0.1,2.6,0.5,8-4.4,11.9c-3.2,2.6-8.6-3.6-9.4-9.8c-0.7-6.3,2-10.3,5.7-11
	C34.1,3.2,32.3,8.7,32.2,14.2L32.2,14.2L32.2,14.2z"></path><path class="st10" d="M24.2,8.8c-1,1.3-0.5,2.1-3.4,2.6c-0.1,1.4,0,3-0.4,3.7c0,0.1-0.1,0.1-0.1,0.2c0,0-0.1,0.1-0.1,0.2
	c-0.2,0.2-0.4,0.2-0.8-0.1c-1.7-1.2-3.3-1.9-3.8-3.4c-0.5-1.5-0.9-4.8,0.1-6.2c0.2-0.3,0.4-0.5,0.7-0.6c0.1-0.1,0.3-0.1,0.4-0.1
	C16.9,5,17,4.9,17,4.8c0-0.1,0.1-0.1,0.1-0.2c0.1-0.2,0.3-0.4,0.4-0.7c2.4-3.5,6.4-3.6,5.5-2c3.1-3.1,13.1-0.3,12.8,4.7
	C41,14.7,27.4,12.6,24.2,8.8z"></path><path class="st10" d="M16.8,5.3c0,0-0.8-0.2-1-0.1c-0.2,0.1,0.1-0.7,0.3-0.7c0.2,0,0.8,0.2,1,0.4c0-0.5-0.2-1.5,0.2-1.6
	c0.4-0.1,0.1,1,0.1,1L16.8,5.3C16.8,5.3,16.8,5.3,16.8,5.3z"></path><path class="st11" d="M20.9,11.4c-0.1,1.4-0.1,3.1-0.5,3.8c0,0.1-0.1,0.1-0.1,0.2c0,0.1-0.1,0.1-0.1,0.1l0,0c-0.2,0.2-0.5,0.1-1-0.2
	c-1.6-1.2-3.2-1.9-3.6-3.4s-0.9-4.8,0.1-6.2c0.7,1.5,2.1,3.1,3.2,3C20,8.7,20.9,11.4,20.9,11.4z"></path><path class="st12" d="M7.1,46.8c0,0,1.1-4.7,0.9-7c-0.2-2.4,0.9,5.7,0.8,6.2c-0.2,0.4,22.2-3,23.4-2.3C30.6,44.1,9.8,46.6,7.1,46.8
	L7.1,46.8L7.1,46.8z"></path><path class="st12" d="M33,42.8c0.2-0.5,0.9-3.8-0.6-5.6C32.7,38.5,33,42.8,33,42.8z"></path><g><path class="st5" d="M18.8,12.9c0.2,1.3,0.1,2.6-0.8,2.8c-0.9,0.2-2.1-0.7-2.4-2s0.2-2.5,1.1-2.8C18,10.5,18.6,11.4,18.8,12.9
		L18.8,12.9L18.8,12.9z"></path><path class="st13" d="M16.4,12.5c0.3-0.4,1.9-1.1,1.6,1.4c0,0-0.4-0.7-0.6-0.5"></path></g><g><path class="st14" d="M65.7,35.1l-0.8-1l-2.6,2.4l2.2,2.9l0.9-0.9l-1.5-1.8L65.7,35.1z"></path><polygon class="st15" points="67.1,39.9 67.1,40 66.8,41.7 65.6,41.4 65.7,41 	"></polygon><polygon class="st14" points="68.6,32.6 67.1,39.9 65.7,41 65.7,40.9 65.7,40.9 67.4,32.3 	"></polygon><polygon class="st15" points="72,37.4 69.3,39.8 68.7,39 68.6,38.8 68.6,38.8 71.4,36.7 71.7,37.1 	"></polygon><polygon class="st14" points="68.6,38.8 70.3,37.2 68.8,35.4 69.7,34.5 71.4,36.7 	"></polygon></g><path class="st0" d="M156.9,48.2v-0.9h-15.2v1.8h14.8L156.9,48.2L156.9,48.2z"></path><path class="st1" d="M150.2,47.3l-1,1.8h-7.4v-1.8H150.2L150.2,47.3z"></path><path class="st2" d="M162.7,25.7l-8,23.3h1.4l8-23.3H162.7L162.7,25.7z"></path><path class="st3" d="M177.6,49.1l7.6-22.6l-21.1-0.7l-8,23.3H177.6L177.6,49.1z"></path><polygon class="st4" points="183.8,30.7 181.2,38.5 168.2,49.1 160.4,49.1 170.9,40.9 170.8,41.3 171.8,41.5 172.1,40 172.1,39.9 
	173.4,38.9 173.5,39.1 174.1,39.8 176.4,37.6 176.1,37.3 175.9,36.9 "></polygon><path class="st4" d="M173.1,49.1l6.2-5.1l-1.7,5.1H173.1z"></path><path class="st5" d="M118.9,44.9l-0.1,1l-0.2,1.3c-2.3,0.2-5.6,1.2-7.4,1.7c-0.4,0.1-0.7,0.2-0.9,0.3c0-0.3,0.1-3.2,0.3-5.1
	c0,0,0.5-0.3,1.3-0.6l0,0c1.4-0.7,3.6-1.8,3.8-1.9c0.1,0,0.2,0,0.4,0.2C117,42.5,118.9,44.9,118.9,44.9L118.9,44.9L118.9,44.9z"></path><path class="st6" d="M119.7,45.9l-0.9,0l-7.4,0.2l-0.2,2.8c-0.4,0.1-0.6,0.2-0.9,0.3c0-0.3,0.1-3.2,0.3-5.1c0,0,0.5-0.3,1.3-0.6l0,0
	l4.2-1.7L118,41L119.7,45.9L119.7,45.9L119.7,45.9z"></path><path class="st5" d="M141.9,42.7c0.9-1.6,5.2-4.7,6.9-5c0.6,0,0.1,2-1.9,2.9c1.7-0.2,9-0.3,8.9,0.8c0,0.9-0.3,1-0.8,2.2
	s-0.5,2.5-1.6,2.8c-2.7,1-2.1-0.6-6.3,0.3c-1.3,0.7-2,1.8-3.1,2.1L141.9,42.7L141.9,42.7L141.9,42.7z"></path><path class="st7" d="M142,42.8c0.7-1,4.8-4.4,6.5-5c0.3-1.4-1.9-9.8-3.5-10.5c-1.7-1-3.9-1.7-4.8-1.9c-0.3-0.1-1.3-0.5-2.6-0.8
	c-0.1,0-0.1,0-0.1,0c-2.8-0.7-7.1-1.6-9.9-1.6c-0.3,0-0.6,0-0.9,0c-0.3,0-0.6,0.1-1,0.1c-3.5,0.4-10.8,1.6-11.8,3
	c-1.6,2.5-5.5,14.8-3.7,22.9H141c0,0,2.4,0,3.1-0.6C144.1,45.7,142.6,43,142,42.8L142,42.8L142,42.8z"></path><path class="st8" d="M138.1,25c0,0.2,0,0.4-0.1,0.6c-0.1,0.4-0.1,0.8-0.3,1.2c-0.1,0.3-0.3,0.6-0.4,0.8c-3.6,5.9-12.6,3.4-11.7-4.4
	c0.4-0.1,0.7-0.1,1-0.1c0.3,0,0.6,0,0.9,0c2.9,0,7.4,1,10.4,1.9C138,24.9,138.1,24.9,138.1,25L138.1,25L138.1,25z"></path><path class="st5" d="M136.7,26c0.1,2.3-8.6,5.5-9.5-1c-0.1-0.5-0.1-1.1,0-1.8c0.5-0.7,1-3.4,1.4-5.9c0-0.1,0-0.1,0.1-0.2
	C129.4,15.8,136.6,21.8,136.7,26L136.7,26L136.7,26z"></path><g><path class="st6" d="M128.6,17.4c0,0,8.1,8.3,8.1,8.6C131,26.1,128.8,23.5,128.6,17.4z"></path><path class="st6" d="M130,18.8l-0.5,1c0,0-0.6,3.8-2.2,5.2c-0.1-0.5-0.1-1.1,0-1.8c0.6-0.7,1-3.4,1.4-5.9l1.3-0.2L130,18.8
		L130,18.8z"></path></g><path class="st9" d="M138.1,25c0,0,0,1.4-0.5,2l-1.2-0.1c0,0,0.4-0.6,0.3-1.1s0.6-1.6,0.6-1.6L138.1,25L138.1,25z"></path><path class="st5" d="M142,13.4c0.1,2.6,0.5,8-4.4,11.9c-3.2,2.6-8.6-3.6-9.4-9.8c-0.7-6.3,2-10.3,5.7-11C143.9,2.4,142.2,8,142,13.4
	L142,13.4L142,13.4z"></path><path class="st10" d="M134.1,8c-1,1.3-0.5,2.1-3.4,2.6c-0.1,1.4,0,3-0.4,3.7c0,0.1-0.1,0.1-0.1,0.2c0,0-0.1,0.1-0.1,0.2
	c-0.2,0.2-0.4,0.2-0.8-0.1c-1.7-1.2-3.3-1.9-3.8-3.4c-0.5-1.5-0.9-4.8,0.1-6.2c0.2-0.3,0.4-0.5,0.7-0.6c0.1-0.1,0.3-0.1,0.4-0.1
	c0.1-0.1,0.1-0.2,0.2-0.3c0-0.1,0.1-0.1,0.1-0.2c0.1-0.2,0.3-0.4,0.4-0.7c2.4-3.5,6.4-3.6,5.5-2c3.1-3.1,13.1-0.3,12.8,4.7
	C150.9,13.9,137.2,11.8,134.1,8z"></path><path class="st10" d="M126.6,4.5c0,0-0.8-0.2-1-0.1c-0.2,0.1,0.1-0.7,0.3-0.7s0.8,0.2,1,0.4c0-0.5-0.2-1.5,0.2-1.6
	c0.4-0.1,0.1,1,0.1,1L126.6,4.5C126.6,4.5,126.6,4.5,126.6,4.5z"></path><path class="st11" d="M130.7,10.6c-0.1,1.4-0.1,3.1-0.5,3.8c0,0.1-0.1,0.1-0.1,0.2c0,0.1-0.1,0.1-0.1,0.1l0,0
	c-0.2,0.2-0.5,0.1-1-0.2c-1.6-1.2-3.2-1.9-3.6-3.4c-0.4-1.5-0.9-4.8,0.1-6.2c0.7,1.5,2.1,3.1,3.2,3C129.9,8,130.7,10.6,130.7,10.6z"></path><path class="st12" d="M116.9,46c0,0,1.1-4.7,0.9-7c-0.2-2.4,0.9,5.7,0.8,6.2c-0.2,0.4,22.2-3,23.4-2.3
	C140.4,43.4,119.6,45.8,116.9,46L116.9,46L116.9,46z"></path><path class="st12" d="M142.9,42c0.2-0.5,0.9-3.8-0.6-5.6C142.5,37.8,142.9,42,142.9,42z"></path><g><path class="st5" d="M128.6,12.1c0.2,1.3,0.1,2.6-0.7,2.8c-0.9,0.2-2.1-0.7-2.4-2c-0.3-1.3,0.2-2.5,1.1-2.8
		C127.8,9.7,128.5,10.7,128.6,12.1L128.6,12.1L128.6,12.1z"></path><path class="st13" d="M126.2,11.8c0.3-0.4,1.8-1.1,1.6,1.4c0,0-0.4-0.7-0.6-0.5"></path></g><g><path class="st14" d="M170.9,35.5l-0.7-0.9l-2.3,2.3l1.9,2.6l0.8-0.8l-1.3-1.7L170.9,35.5z"></path><polygon class="st15" points="172.1,39.9 172.1,40 171.8,41.5 170.8,41.3 170.9,40.9 	"></polygon><polygon class="st14" points="173.5,33.1 172.1,39.9 170.9,40.9 170.9,40.8 170.9,40.8 172.4,32.9 	"></polygon><polygon class="st15" points="176.4,37.6 174.1,39.8 173.5,39.1 173.4,38.9 173.4,38.9 175.9,36.9 176.1,37.3 	"></polygon><polygon class="st14" points="173.4,38.9 174.9,37.4 173.6,35.7 174.4,34.9 175.9,36.9 	"></polygon></g></svg></a> <div class="flex items-center space-x-1"><button class="p-2 text-purple-800 dark:text-yellow-200"><div><svg class="h-8 w-8 fill-current" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3.722 3.193L3.226 4.528c-.12.323-.375.578-.698.698L1.193 5.722c-.257.096-.257.46 0 .555l1.335.496c.323.12.578.375.698.698l.496 1.335c.096.257.46.257.555 0l.496-1.335c.12-.323.375-.578.698-.698l1.335-.496c.257-.096.257-.46 0-.555L5.472 5.226c-.323-.12-.578-.375-.698-.698L4.278 3.193C4.182 2.936 3.818 2.936 3.722 3.193zM20.916 12.994c.603.006 1.091.516 1.008 1.113-.232 1.662-.986 3.267-2.263 4.553-3.13 3.12-8.19 3.12-11.32 0-3.12-3.13-3.12-8.19 0-11.32 1.285-1.277 2.891-2.032 4.553-2.263C13.49 4.993 14 5.481 14.006 6.084c.017 1.765.7 3.521 2.044 4.866C17.394 12.294 19.151 12.977 20.916 12.994z"></path></svg></div></button> <a class="rounded-lg p-2 text-gray-700 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-800" href="https://www.youtube.com/@moomincare" target="_blank"><svg class="h-8 w-8 fill-current" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24"><path d="M21.582,6.186c-0.23-0.86-0.908-1.538-1.768-1.768C18.254,4,12,4,12,4S5.746,4,4.186,4.418 c-0.86,0.23-1.538,0.908-1.768,1.768C2,7.746,2,12,2,12s0,4.254,0.418,5.814c0.23,0.86,0.908,1.538,1.768,1.768 C5.746,20,12,20,12,20s6.254,0,7.814-0.418c0.861-0.23,1.538-0.908,1.768-1.768C22,16.254,22,12,22,12S22,7.746,21.582,6.186z M10,14.598V9.402c0-0.385,0.417-0.625,0.75-0.433l4.5,2.598c0.333,0.192,0.333,0.674,0,0.866l-4.5,2.598 C10.417,15.224,10,14.983,10,14.598z"></path></svg></a> <a class="rounded-lg p-2 text-gray-700 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-800" href="https://github.com/xxieen" target="_blank"><svg class="h-8 w-8 fill-current" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24"><path d="M10.9,2.1c-4.6,0.5-8.3,4.2-8.8,8.7c-0.5,4.7,2.2,8.9,6.3,10.5C8.7,21.4,9,21.2,9,20.8v-1.6c0,0-0.4,0.1-0.9,0.1 c-1.4,0-2-1.2-2.1-1.9c-0.1-0.4-0.3-0.7-0.6-1C5.1,16.3,5,16.3,5,16.2C5,16,5.3,16,5.4,16c0.6,0,1.1,0.7,1.3,1c0.5,0.8,1.1,1,1.4,1 c0.4,0,0.7-0.1,0.9-0.2c0.1-0.7,0.4-1.4,1-1.8c-2.3-0.5-4-1.8-4-4c0-1.1,0.5-2.2,1.2-3C7.1,8.8,7,8.3,7,7.6c0-0.4,0-0.9,0.2-1.3 C7.2,6.1,7.4,6,7.5,6c0,0,0.1,0,0.1,0C8.1,6.1,9.1,6.4,10,7.3C10.6,7.1,11.3,7,12,7s1.4,0.1,2,0.3c0.9-0.9,2-1.2,2.5-1.3 c0,0,0.1,0,0.1,0c0.2,0,0.3,0.1,0.4,0.3C17,6.7,17,7.2,17,7.6c0,0.8-0.1,1.2-0.2,1.4c0.7,0.8,1.2,1.8,1.2,3c0,2.2-1.7,3.5-4,4 c0.6,0.5,1,1.4,1,2.3v2.6c0,0.3,0.3,0.6,0.7,0.5c3.7-1.5,6.3-5.1,6.3-9.3C22,6.1,16.9,1.4,10.9,2.1z"></path></svg></a></div></nav></header> <main class="mx-auto max-w-5xl pt-24"><article><header class="p-4"><div class="mb-6 w-full sm:w-3/5"><div class="aspect-h-9 aspect-w-16 overflow-hidden rounded-lg"><img src="/post-images/value_cat.png" alt="C++中的值类别" class="object-cover"></div></div> <div><h1 class="mb-4 text-4xl font-bold">C++中的值类别</h1> <div class="inline-block border-t py-2 dark:border-gray-700"><span data-svelte-h="svelte-1e205ie">Published:</span> <time class="font-light" datetime="2024-9-11">September 10, 2024</time></div></div></header> <div class="prose max-w-none px-4 py-4 dark:prose-invert"><p data-svelte-h="svelte-1jif6gp">表达式是C++语言的基石。每个表达式都有两个属性：类型（type）和值类别（value category）。前者是大家都熟悉的，但是后者却可能是我们不太在意的。本文的目的是介绍与值类别相关的一些知识。</p> <h2 data-svelte-h="svelte-1wiu2u3">前言</h2> <p data-svelte-h="svelte-18b73b3">本文是C++基础系统文章中的一篇，将介绍C++中的值类别，以及与之相关的一些概念。</p> <h2 data-svelte-h="svelte-74gb97">表达式与值类别</h2> <p data-svelte-h="svelte-wp3nrc">C++的程序由一系列的表达式（expressions）构成。表达式是运算符和操作数的序列，表达式指定一项计算。</p> <p data-svelte-h="svelte-1b5xxra">例如：<code>2 + 2</code> 或者 <code>std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl</code>都是表达式。</p> <p data-svelte-h="svelte-ow824m">每个表达式有两个互相独立但是非常重要的属性：</p> <ul data-svelte-h="svelte-dyvvas"><li>类型（type）。类型是我们很熟悉的概念，<code>int</code>，<code>double</code>和<code>std::string</code>这些都是类型。类型确定了表达式可以进行哪些操作。</li> <li>除了类型之外，还有一个称之为值类别（value category）的属性，却可能是我们平时不太注意的。</li></ul> <p data-svelte-h="svelte-1fg3kw8">⠀</p> <blockquote data-svelte-h="svelte-1x9de7y"><p>type和category在中文中似乎都可以翻译成“类型”。但在本文中，为了区分它们，统一将type翻译成“类型”，category翻译成“类别”。</p></blockquote> <h2 data-svelte-h="svelte-1eyomnr">为什么要懂这些东西？</h2> <p data-svelte-h="svelte-14fila8">不管你在不在意，每个表达式都属于三种值类别（prvalue，xvalue，lvalue）中的一种。值类别可以影响表达式的含义，例如：你应该知道这个表达式是没有意义的：<code>3 = 4</code>，它甚至编译不过。但你可能说不出来为什么编译器会认为它编译不过。</p> <p data-svelte-h="svelte-1xncu27">如果你使用gcc编译器，它的报错如下：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">error<span class="token operator">:</span> lvalue required as left operand of assignment</code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1so52ri">这个报错中的<code>lvalue</code>就是数字表达式<code>3</code>的值类别。</p> <p data-svelte-h="svelte-l096ke">再者，值类别还会影响函数的重载：当某个函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。如果你不明白这里提到的“左值引用”和“右值”是指什么的话请不要担心，这就是本文所要说明的。</p> <h2 data-svelte-h="svelte-fndswg">从左值和右值说起</h2> <p data-svelte-h="svelte-1natae4">最初的时候，只有左值（lvalue）和右值（rvalue）这两个术语。它们源于C++的祖先语言：<a href="https://en.wikipedia.org/wiki/CPL_(programming_language)" rel="nofollow">CPL</a>。</p> <p data-svelte-h="svelte-1l4n4mx">lvalue之所以叫lvalue，是因为它常常出现在等号的左边（left-hand side of an assignment）。同样，rvalue是因为它常常出现在等号的右边（right-hand side of an assignment）。</p> <p data-svelte-h="svelte-j3gtre">回顾一下上面的<code>3 = 4</code>编译报错，就是因为编译器要求等号的左边得是一个lvalue，而数字<code>3</code>其实是一个rvalue，所以这个是无法通过编译的。</p> <p data-svelte-h="svelte-fel0l7">C语言遵循了相似的分类法，但是否需要等号赋值已经不再重要。在C语言中，标识一个对象的表达式称之为左值，不过lvalue已经是“locator value”的简写，因为lvalue对应了一块内存地址。</p> <p data-svelte-h="svelte-1pnu4wu">你可以简单的理解为：<strong>左值对应了具有内存地址的对象，而右值仅仅是临时使用的值</strong>。例如<code>int a = 1</code>中，<code>a</code>是左值，<code>1</code>是右值。</p> <h2 data-svelte-h="svelte-1lk2zfc">C++11中的值类别</h2> <p data-svelte-h="svelte-8qtk3v">C++中对于值类别的定义也经历一些变化。从C++11标准开始，值类别早以不止是lvalue和rvalue两种这么简单。</p> <p data-svelte-h="svelte-145j1ia">但情况也不算太坏，因为主要的值类别有：lvalue，prvalue 和 xvalue三种。加上两种混合类别：glvalue和rvalue，一共有五种。</p> <p data-svelte-h="svelte-1fdqwcu">我们来看一下它们的定义：</p> <ul data-svelte-h="svelte-1ay4qgh"><li>A <strong>glvalue</strong>（generalized lvalue） is an expression whose evaluation determines the identity of an object, bit-field, or function.</li> <li>A <strong>prvalue</strong>（pure rvalue） is an expression whose evaluation initializes an object or a bit-field, or computes the value of an operand of an operator, as specified by the context in which it appears, or an expression that has type cv void.</li> <li>An <strong>xvalue</strong>（eXpiring value） is a glvalue that denotes an object or bit-field whose resources can be reused （usually because it is near the end of its lifetime）.</li> <li>An <strong>lvalue</strong> is a glvalue that is not an xvalue.</li> <li>An <strong>rvalue</strong> is a prvalue or an xvalue.</li></ul> <p data-svelte-h="svelte-5bu0fc">⠀
这个定义很难理解，就算翻译成中文，也一样不好理解。所以下文会通过一些示例来对它们进行说明。</p> <p data-svelte-h="svelte-ibmlmy">这五种类别的分类基于表达式的两个特征：</p> <ul data-svelte-h="svelte-yoa75y"><li>是否拥有身份（identity）：可以确定表达式是否与另一表达式指代同一实体，例如比较它们所标识的对象或函数的（直接或间接获得的）地址；</li> <li>是否可被移动（具体见下文）：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定到这个表达式。</li></ul> <p data-svelte-h="svelte-qatyqk">⠀
由此，C++11中对于这五种类别定义如下：</p> <ul data-svelte-h="svelte-orhxl7"><li>lvalue是指：拥有身份且不可被移动的表达式。</li> <li>xvalue是指：拥有身份且可被移动的表达式。</li> <li>prvalue是指：不拥有身份且可被移动的表达式。</li> <li>glvalue是指：拥有身份的表达式，lvalue和xvalue都是glvalue。</li> <li>rvalue是指：可被移动的表达式。prvalue和xvalue都是rvalue。</li></ul> <p data-svelte-h="svelte-1iz0n6c">⠀
这么说起来还是有些拗口，不过其实颠来倒去就是两个特征的“是”与“否”，所以通过一个2x2的表格就很容易描述清楚了：</p> <table data-svelte-h="svelte-7qzbn3"><thead><tr><th> </th> <th>拥有身份（glvalue）</th> <th>不拥有身份</th></tr></thead> <tbody><tr><td><strong>可移动（rvalue）</strong></td> <td>xvalue</td> <td>prvalue</td></tr> <tr><td><strong>不可移动</strong></td> <td>lvalue</td> <td>不存在</td></tr></tbody></table> <blockquote data-svelte-h="svelte-9bnjz8"><p>注：不存在不拥有身份也不可移动的表达式。</p></blockquote> <p data-svelte-h="svelte-1tpewue">我们可以通过下面这个图来记忆五种类别的关系：</p> <p data-svelte-h="svelte-1bhh8b8"><img src="/post-images/value_cat.png" alt="image1"></p> <p data-svelte-h="svelte-c6utm1">每种值类别都有其关联的性质，这些性质决定了表达式可以如何使用。</p> <h2 data-svelte-h="svelte-1gi6kem">glvalue</h2> <p data-svelte-h="svelte-14peliv">glvalue是拥有身份的表达式，它对应了一块内存地址。glvalue有lvalue和xvalue两种形式，具体的示例见下文。</p> <p data-svelte-h="svelte-1kt479z">glvalue具有以下一些特性：</p> <ul data-svelte-h="svelte-13yft1b"><li>glvalue可以自动转换成prvalue。例如：<code>int a = b</code>，等号右边的lvalue会自动转换成rvalue。</li> <li>glvalue可以是多态的（polymorphic），它所对应了动态类型和静态类型可以不一样，例如：一个指向子类的父类指针。</li> <li>glvalue可以是不完整类型，只要表达式允许。例如：由前置声明但未定义的类类型。</li></ul> <p data-svelte-h="svelte-1fg3kw8">⠀</p> <h2 data-svelte-h="svelte-1e6x605">rvalue</h2> <p data-svelte-h="svelte-g4gav6">rvalue是指可以移动的表达式。prvalue和xvalue都是rvalue，具体的示例见下文。</p> <p data-svelte-h="svelte-14s7vb1">rvalue具有以下特征：</p> <ul data-svelte-h="svelte-1bzc6tl"><li>无法对rvalue进行取地址操作。例如：<code>&amp;42</code>，<code>&amp;i++</code>，这些表达式没有意义，也编译不过。</li> <li>rvalue不能放在赋值或者组合赋值符号的左边，例如：<code>3 = 5</code>，<code>3 += 5</code>，这些表达式没有意义，也编译不过。</li> <li>rvalue可以用来初始化const左值引用（见下文）。例如：<code>const int&amp; a = 1</code>。</li> <li>rvalue可以用来初始化右值引用（见下文）。</li> <li>rvalue可以影响函数重载：当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const 的左值引用的形参时，右值将被绑定到右值引用的重载之上。</li></ul> <p data-svelte-h="svelte-1330jxo">⠀
下面是三种具体的值类别：</p> <h2 data-svelte-h="svelte-1dronuj">lvalue</h2> <p data-svelte-h="svelte-1wmyyxu">左值是指拥有身份但不可移动的表达式。</p> <p data-svelte-h="svelte-iuxuer">变量，函数或者数据成员的名称都是左值表达式。下面是一些左值的例子：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token string">"hello world"</span> <span class="token comment">// lvalue</span>
<span class="token keyword">int</span> a<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// lvalue</span>
<span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token comment">// lvalue int&amp; get() &#123;return a;&#125;</span>
<span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lvalue int b[4]&#123;&#125;; // lvalue</span>
b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// lvalue int foo();</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>a <span class="token punctuation">&#123;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// lvalue struct foo &#123;int a;&#125;;</span>
foo f<span class="token punctuation">;</span> <span class="token comment">// lvalue</span>
f<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// lvalue int &amp;&amp;c&#123; 55 &#125;; // lvalue</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>d<span class="token punctuation">&#123;</span> a <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// lvalue</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-14s6hk3">lvalue具有以下特征：</p> <ul data-svelte-h="svelte-jaynmp"><li>所有glvalue具有的特征</li> <li>可以通过取址运算符获取其地址</li> <li>可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数</li> <li>可以用来初始化左值引用（见下文）</li></ul> <p data-svelte-h="svelte-1fg3kw8">⠀</p> <h2 data-svelte-h="svelte-1r6cetn">prvalue</h2> <p data-svelte-h="svelte-1b8a4kp">prvalue是纯右值，数字字面值或者函数返回的是非引用的值都是prvalue。</p> <p data-svelte-h="svelte-18vsbp4">下面一些prvalue的例子：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token number">42</span> <span class="token comment">// prvalue</span>
<span class="token boolean">true</span> <span class="token comment">// prvalue int foo();</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// prvalue int a&#123;&#125;, b&#123;&#125;; // both lvalues</span>
a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// prvalue</span>
<span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// prvalue a++ // prvalue</span>
b<span class="token operator">--</span> <span class="token comment">// prvalue</span>
a <span class="token operator">&amp;&amp;</span> b <span class="token comment">// prvalue</span>
a <span class="token operator">&lt;</span> b <span class="token comment">// prvalue double &#123;&#125;; // prvalue</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>X<span class="token operator">></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// prvalue</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1kqy0nn">prvalue具有以下特征：</p> <ul data-svelte-h="svelte-upeaav"><li>所有rvalue具有的特征</li> <li>prvalue不会是多态的</li> <li>prvalue不会是不完全类型</li> <li>prvalue不会是抽象类型或数组</li></ul> <p data-svelte-h="svelte-1fg3kw8">⠀</p> <h2 data-svelte-h="svelte-1e3eqwf">xvalue</h2> <p data-svelte-h="svelte-bgxqvu">xvalue也指向了一个对象，不过这个对象已经接近了生命周期的末尾。这通常和移动语义（见下文）有关。</p> <p data-svelte-h="svelte-83c72i">下面是一些示例：</p> <blockquote data-svelte-h="svelte-yjy0da"><p>xvalue与右值引用有很强的关联性，因此看了下文对于右值引用的说明再回过头来看xvalue会更好理解。</p></blockquote> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">bool</span> b <span class="token punctuation">&#123;</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// lvalue</span>
std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xvalue</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xvalue int&amp;&amp; foo();</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xvalue struct foo &#123;int a;&#125;;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// xvalue</span>
foo<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// xvalue int a[4]&#123;&#125;;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xvalue</span>
std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// xvalue using arr = int[2];</span>
arr<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// xvalue</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1vjgttu">xvalue具有所有rvalue和glvalue所有的特征。</p> <h2 data-svelte-h="svelte-hwxkvp">左值引用与右值引用</h2> <blockquote data-svelte-h="svelte-e70twe"><p>注意：左值引用和右值引用不属于值类别（value category），它们是表达式的类型（type），并且都是组合类型（compound type）。</p></blockquote> <p data-svelte-h="svelte-1tdrwte">我相信每一个C++程序员一定都会知道什么“引用”，但可能并非每个人都知道什么是“右值引用”（rvalue reference）。</p> <p data-svelte-h="svelte-qfekow">在C++11之前，引用分为const引用和非const引用。这两种引用在C++11中都称做左值引用（lvalue reference）。</p> <p data-svelte-h="svelte-pcrt8l">无法将非const左值引用指向右值。例如，下面这行代码是无法通过编译的：</p> <p data-svelte-h="svelte-gckl22">编译器的报错是：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">error<span class="token operator">:</span> non<span class="token operator">-</span><span class="token keyword">const</span> lvalue reference to type <span class="token char">'int'</span> cannot bind to a temporary of type <span class="token char">'int'</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-6el1x1">它的意思是：你无法将一个非const左值引用指向一个临时的值。</p> <p data-svelte-h="svelte-vg24bj">但是const类型的左值引用是可以绑定到右值上的，所以下面这行代码是没问题的：</p> <p data-svelte-h="svelte-ot27vl">不过，由于这个引用是const的，因此你无法修改其值的内容。</p> <p data-svelte-h="svelte-81y1pu">C++11新增了右值引用，左值引用的写法是<code>&amp;</code>，右值引用的写法是<code>&amp;&amp;</code>。</p> <p data-svelte-h="svelte-9tpocg">右值是一个临时的值，右值引用是指向右值的引用。右值引用延长了临时值的生命周期，并且允许我们修改其值。</p> <p data-svelte-h="svelte-j60871">例如：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string s1 <span class="token operator">=</span> <span class="token string">"Hello "</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> s_rref <span class="token operator">=</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span> <span class="token comment">// the result of s1 + s2 is an rvalue</span>
s_rref <span class="token operator">+=</span> <span class="token string">", my friend"</span><span class="token punctuation">;</span> <span class="token comment">// I can change the temporary string!</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s_rref <span class="token operator">&lt;&lt;</span> <span class="token char">'&#92;n'</span><span class="token punctuation">;</span> <span class="token comment">// prints "Hello world, my friend"</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-5r3id4">在上面这个代码中，<code>s_rref</code>是一个指向临时对象的引用：右值引用。由于这里没有const，因此我们可以借此修改临时对象的内容。</p> <p data-svelte-h="svelte-10hlhp9">右值引用使得我们可以创建出以此为基础的函数重载，例如：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue reference version"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue reference version"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1gav8mq">当传入的参数是一个左值时，会绑定到第一个版本上。当传入的参数是一个右值时，会绑定到第二个版本上，以下面这段代码为例：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">X <span class="token function">returnX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> X x<span class="token punctuation">;</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">returnX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-ayxofe">其输出是：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">lvalue reference version
rvalue reference version</code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-11628w6">我们整理一下上面的内容：</p> <ul data-svelte-h="svelte-gber7f"><li>左值引用：即可以绑定到左值（非const），也可以绑定到右值（const）</li> <li>右值引用：只能绑定到右值</li></ul> <p data-svelte-h="svelte-ghm0a9">⠀
右值引用本身是一个左值还是一个右值？答案是：都有可能。<strong>右值引用既可能是lvalue，也可能是rvalue。如果它有名称，则是lvalue，否则是rvalue。</strong></p> <p data-svelte-h="svelte-huiwur">右值引用是C++11中两个新增功能的语法基础，这两个功能是：</p> <ul data-svelte-h="svelte-hgjrqc"><li>移动语义（Move Semantics）</li> <li>完美转发（Perfect Forward）</li></ul> <p data-svelte-h="svelte-183lb1q">⠀
下面来逐个介绍。</p> <h2 data-svelte-h="svelte-s84vrn">移动语义</h2> <p data-svelte-h="svelte-pmskaz">我们知道，在C++中，你可以为类定义拷贝构造函数（copy constructor）和拷贝赋值（copy assignment）运算符。</p> <p data-svelte-h="svelte-15t0le1">它们看起来像这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token comment">// copy constructor &#123; m_data = new int[other.m_size]; std::copy(other.m_data, other.m_data + other.m_size, m_data); m_size = other.m_size; &#125; X&amp; operator=(X other) // copy assignment &#123; if(this == &amp;other) return *this; delete[] m_data; m_data = new int[other.m_size]; std::copy(other.m_data, other.m_data + other.m_size, m_data); m_size = other.m_size; return *this; &#125; X&amp; operator=(const X&amp; other) // copy assignment &#123; if(this == &amp;other) return *this; delete[] m_data; m_data = new int[other.m_size]; std::copy(other.m_data, other.m_data + other.m_size, m_data); m_size = other.m_size; return *this; &#125; private: int* m_data; size_t m_size;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <blockquote data-svelte-h="svelte-6frf41"><p>当然，如果你为类定义了拷贝构造函数和拷贝赋值运算符，你通常还应当为其定义析构函数。这称之为<a href="https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29" rel="nofollow">Rule of Three</a>。</p></blockquote> <p>拷贝意味着会将原先的数据复制一份新的出来。这么做的好处是：新的数据与原先的数据是独立的两份，修改其中一个不会影响另外一个。但坏处是：这么做会消耗运算时间和存储空间。例如：你有一个包含了$10^10$个元素的集合数据，将其拷贝一份就不那么轻松了。</p> <p data-svelte-h="svelte-icp4re"><img src="/post-images/copy.png" alt="image2"></p> <p data-svelte-h="svelte-hc5hxm">而移动操作则轻量了很多，因为它不涉及新数据的产生，仅仅是将原先的数据更改拥有者。</p> <p data-svelte-h="svelte-t6lxlb"><img src="/post-images/move.png" alt="image3"></p> <p data-svelte-h="svelte-1cr9v7n">在C++11中，你可以为类定义移动构造函数（move constructor）和移动赋值（move assignment）运算符。它们看起来是这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
X<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1jy96la">你应该已经看出，这里用到的都是右值引用。</p> <p data-svelte-h="svelte-wlv6hd">继续以上面定义的类型为例，其移动构造函数和移动赋值运算符的实现可能是这样的：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token comment">// &lt;-- rvalue reference in input</span>
<span class="token punctuation">&#123;</span> m_data <span class="token operator">=</span> other<span class="token punctuation">.</span>m_data<span class="token punctuation">;</span> <span class="token comment">// ① m_size = other.m_size; other.m_data = nullptr; // ② other.m_size = 0;</span>
<span class="token punctuation">&#125;</span> X<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token comment">// &lt;-- rvalue reference in input</span>
<span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m_data<span class="token punctuation">;</span> <span class="token comment">// ③ m_data = other.m_data; // ④ m_size = other.m_size; other.m_data = nullptr; // ⑤ other.m_size = 0; return *this;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-i4wtzx">在这段代码中：</p> <ol data-svelte-h="svelte-160urpd"><li>获取<code>other</code>对象所包含的值</li> <li>处理<code>other</code>的内部结构，防止再次使用</li> <li>释放自身包含的指针</li> <li>获取<code>other</code>对象所包含的值</li> <li>处理<code>other</code>的内部结构，防止再次使用</li></ol> <p data-svelte-h="svelte-8zhw65">⠀
现在，该类有了拷贝和移动两种操作，那编译器如何知道该选择哪个呢？答案是，根据传入的参数类型：如果是左值引用，则使用拷贝操作；如果是右值引用，则使用移动操作。</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">X <span class="token function">createX</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span> X <span class="token function">h1</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// regular constructor X h2(h1); // copy constructor (lvalue in input) X h3 = createX(2000); // move constructor (rvalue in input)  h2 = h3; // assignment operator (lvalue in input) h2 = createX(500); // move assignment operator (rvalue in input)</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-15pmcgw">这里的两次移动操作避免了数据复制的资源消耗。</p> <p data-svelte-h="svelte-dbxoua">接下来的问题是：如果是左值，也能调用移动操作吗？</p> <p data-svelte-h="svelte-144480e">答案是肯定的，借助<code>std::move()</code>即可。</p> <p data-svelte-h="svelte-x0d4dx"><code>std::move()</code>的名称具有一定的迷惑性，因为它并没有进行任何“移动”的操作，它仅仅是：<strong>无条件的将实参强制转换成右值引用</strong>，仅此而已。因此C++之父认为它的名字叫做<code>rval()</code>应该更合适。但是不管怎么样，由于历史原因，它已经叫做<code>std::move()</code>。</p> <p data-svelte-h="svelte-10v21w8">所以，下面这个代码中<code>x2</code>构造时调用的也是移动构造函数：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">X <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
X <span class="token function">x2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-vbr9wt">不过需要注意的是，由于<code>x1</code>其中包含的值已经被移动走了，因此你不应当再使用它了。</p> <p data-svelte-h="svelte-1l7ntcf">有了右值引用和移动操作之后，STL中的集合操作变得更加高效了，例如：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ①</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ②</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-sdi1uq">这里的①将复制一个字符串添加到集合中，而②是将已有的对象移动进集合中，因此自然是更高效的。</p> <h2 data-svelte-h="svelte-4oysx6">perfect forward</h2> <p data-svelte-h="svelte-t91nvm">在C++11之前，C++语言存在一个称之为“<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm" rel="nofollow">The Forwarding Problem</a>”的问题。</p> <p data-svelte-h="svelte-ciwe">这个问题直到C++11才得以解决。不过要说清楚这个问题并不那么容易。下面以一个具体的代码示例来说明。</p> <p data-svelte-h="svelte-1xrs4ub">一直以来，我们都是通过<code>push_back</code>方法往<code>vector</code>中添加对象的：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyKlass</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">MyKlass</span><span class="token punctuation">(</span><span class="token keyword">int</span> ii_<span class="token punctuation">,</span> <span class="token keyword">float</span> ff_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> some function <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>MyKlass<span class="token operator">></span> v<span class="token punctuation">;</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">MyKlass</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1vw2oxd">但看了上面的内容，你应该已经意识到，这样的方式是通过拷贝的形式完成添加的：要先创建出一个临时对象来，然后拷贝进集合中，这样做效率不够高。更好的方法当时是通过移动。于是C++11为集合类添加了 <a href="https://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&search=emplace" rel="nofollow">emplace</a> 和 <a href="https://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&search=emplace_back" rel="nofollow">emplace_back</a> 方法。</p> <p data-svelte-h="svelte-86wn45"><code>emplace_back</code>用起来像这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp">v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3.14f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-kbjxgn">这个方法接受模板实例类<code>MyKlass</code>的构造函数形参，这样做避免了临时对象的构造。</p> <p data-svelte-h="svelte-e2juu2">但是你有没有想过<code>emplace_back</code>函数是如何实现的呢？我们可以尝试一下。</p> <p data-svelte-h="svelte-quinw0">我们尝试的第一个版本可能是这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>T1 e1<span class="token punctuation">,</span> T2 e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1f61cbo">这个方法存在一个问题，那就是它不支持引用类型。即便<code>func</code>的参数是引用类型的，但是外层<code>emplace_back</code>的参数已经是复制的值。也就说，这里会多一次拷贝。</p> <p data-svelte-h="svelte-aniu0o">于是我们第二个版本将改成这样，把外层的参数也改成引用的：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> T2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-ngabnb">这时又有一个问题：左值引用不能指向右值，所以如果我们这样调用是无法通过编译的：</p> <p data-svelte-h="svelte-nvbi9m">不过const引用是可以指向右值的，所以解决这个问题的办法就是重载：为每个参数定义const和非const两种类型的引用版本，于是乎成了这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> T2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> T2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p>很显然，你马上就意识好像不太对劲。如果是2个参数，需要定义四个重载的版本。那如果是5个参数呢？需要$2^5=32$的版本。如果是10个参数呢？？?</p> <p data-svelte-h="svelte-1r7kzoy">为了解决这个问题，C++11引入了两个新的机制：</p> <ol data-svelte-h="svelte-19cdyeq"><li>Reference Collapsing Rules，我不太确定它的正式中文翻译是什么。我们姑且称之为：引用符号折叠规则。</li> <li>特殊类型推导规则，这个与Universal Reference相关。</li></ol> <p data-svelte-h="svelte-1aaortc">⠀
先说第一个：在C++11中，不存在引用的引用，因此<code>A&amp; &amp;</code>的写法是无法编译的。但在模板类型推导的时候，这是有可能发生的。例如下面这个定义：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">baz</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> T<span class="token operator">&amp;</span> k <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1x7qgi7">当我们用<code>int&amp;</code>去实例化的时候：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">int</span> ii <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token generic-function"><span class="token function">baz</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>ii<span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-6mvjgc">将<code>T</code>替换成<code>int&amp;</code>，于是<code>k</code>的类型就变成了<code>int&amp; &amp;</code>。甚至于，如果用右值引用<code>int&amp;&amp;</code>代替<code>T</code>的话，<code>k</code>的类型就变成了<code>int&amp;&amp; &amp;</code>。</p> <p data-svelte-h="svelte-1eve232">所以C++标准定了一些规则，在这种情况下，编译器会执行Reference Collapsing Rules，具体的规则如下：</p> <ul data-svelte-h="svelte-13wzqa0"><li>如果是 <code>A&amp; &amp;</code> 将变成 <code>A&amp;</code></li> <li>如果是 <code>A&amp; &amp;&amp;</code> 将变成 <code>A&amp;</code></li> <li>如果是 <code>A&amp;&amp; &amp;</code> 将变成 <code>A&amp;</code></li> <li>如果是 <code>A&amp;&amp; &amp;&amp;</code> 将变成 <code>A&amp;&amp;</code></li></ul> <p data-svelte-h="svelte-bcbr06">⠀
简单记忆如下：</p> <ul data-svelte-h="svelte-5dz2w3"><li>两个或者三个<code>&amp;</code>都会变成一个<code>&amp;</code></li> <li>四个<code>&amp;</code>都会变成两个<code>&amp;</code></li></ul> <p data-svelte-h="svelte-56k9n8">⠀
然后我们再说第二个规则：特殊类型推导规则是在特殊的环境下才会产生的推导规则（这好像是一句话废话）。 要理解这个，还需要再借助另外一个术语：Universal Reference，我们可以简称URef。这应该是Scott Meyers（Scott Meyers是世界顶级的C++软件开发技术权威之一，他的《Effective C++》，《More Effective C++》你应该听说过）创造的名词。</p> <p data-svelte-h="svelte-8fannj">关于URef的详细内容可以阅读： <a href="https://paul-pub.oss-cn-beijing.aliyuncs.com/2020/2020-07-cpp-copy-move/URefsCpp11.pdf" rel="nofollow">Scott Meyers 《Universal References in C++11》</a>。</p> <p data-svelte-h="svelte-8e6wxc">URef的定义如下：</p> <p data-svelte-h="svelte-1sqau49"><img src="/post-images/uref.png" alt="image4"></p> <p data-svelte-h="svelte-fmq73a">就是说：只有声明为<code>T&amp;&amp;</code>且T需要推导的情况下，才是URef。例如<code>void f(Widget&amp;&amp; w);</code>，由于不需要推导，所以它不是URef。</p> <p data-svelte-h="svelte-1r8q52s">但下面这个代码中，由于模板需要推导，所以它是URef：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1gtfwau">如果是URef这种情况，则其具有特殊的推导规则。具体描述如下：</p> <ul data-svelte-h="svelte-p4kgys"><li>如果用类型A的左值初始化URef，则URef会变成左值引用 <code>A&amp;</code></li> <li>如果用类型A的右值初始化URef，则URef会变成右值引用 <code>A&amp;&amp;</code></li></ul> <p data-svelte-h="svelte-3g69gl">⠀
这个规则有些奇怪。不过这是C++标准定义，编译器执行的规则，所以我们记住它就好。</p> <p data-svelte-h="svelte-2af29k">除了这两个规则之外，C++还为我们提供了<code>forward</code>函数，该函数有两个重载的版本，定义如下：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-eb4qwv"><code>forward</code>函数依赖<code>&lt;type_traits&gt;</code>头文件中的另外一个结构体<code>remove_reference</code>：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">remove_reference</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-oep22s"><code>remove_reference</code>中包含了一个类型成员名称为<code>type</code>:</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">></span>
<span class="token keyword">using</span> remove_reference_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-d8hkt5">若类型T为引用类型，则成员<code>type</code>为T所引用的类型。否则<code>type</code>为T本身。例如：</p> <ul data-svelte-h="svelte-gu30pb"><li><code>std::remove_reference&lt;int&gt;::type</code> 得到<code>int</code></li> <li><code>std::remove_reference&lt;int&amp;&gt;::type</code> 依旧得到<code>int</code></li> <li><code>std::remove_reference&lt;int&amp;&amp;&gt;::type</code> 仍然得到<code>int</code></li></ul> <p data-svelte-h="svelte-127r75l">⠀
回到<code>forward</code>函数，它借助<code>remove_reference</code>将传入的类型强制转换成对应的<code>T&amp;&amp;</code>形式。</p> <p data-svelte-h="svelte-2q9p8e">回到我们之前的问题上。我们将<code>emplace_back</code>定义成下面这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;&amp;</span> e1<span class="token punctuation">,</span> T2<span class="token operator">&amp;&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">></span></span></span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">></span></span></span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-109pz3a">第一种情况，当我们通过左值去使用它的时候：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">2.0f</span><span class="token punctuation">;</span>
<span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-d6wk47"><code>T</code>替换成<code>int&amp;</code>，<code>emplace_back</code>会变成下面这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span>e1<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span>e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-ym77za">然后我们选取第一个参数为例（第二个参数是类似的），<code>forward</code>会变成这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-sc3q66">然后执行引用符号折叠规则，会变成这样：</p> <pre class="language-cpp"><!-- HTML_TAG_START --><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre> <p data-svelte-h="svelte-1fl7td5">于是调用成功。</p> <p data-svelte-h="svelte-15bsewr">另外一种情况，对于<code>emplace_back(1, 2.0f);</code>调用方式，你可以自行推导一下其变化过程。</p> <p data-svelte-h="svelte-1s9fx1">这个过程通过语言来描述很啰嗦，所以下面通过一幅图来说明整个过程，也希望帮你对比记忆：</p> <p data-svelte-h="svelte-1v5tgmh"><img src="/post-images/forward.png" alt="image5"></p> <h2 data-svelte-h="svelte-g38o1c">参考资料与推荐读物</h2> <p data-svelte-h="svelte-13oqgh3"><a href="https://paul.pub/cpp-value-category/" rel="nofollow">C++中的值类别</a></p></div></article></main> 
			
			<script>
				{
					__sveltekit_18v7y46 = {
						base: new URL("../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("../../_app/immutable/entry/start.CIgtfsuB.js"),
						import("../../_app/immutable/entry/app.C2LByF26.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
  </body>
</html>
